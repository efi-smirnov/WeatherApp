# Checkout Code: This step retrieves the latest code from your repository.
# Prepare Environment: Installs necessary tools (Python, pip, and the AWS Elastic Beanstalk CLI).
# Installing poetry dependencies
# Caching 
# Configure AWS Credentials: Sets up AWS credentials from GitHub secrets to interact with AWS services.
# Login to Amazon ECR: Authenticates with Amazon Elastic Container Registry.
# Build and Tag Docker Image: Builds the Docker image for your application.
# Deploy to Elastic Beanstalk Environment: Initializes and deploys your application to the specified Elastic Beanstalk environment.
# Get Elastic Beanstalk Environment URL: Retrieves the URL of the deployed environment.
# Set Environment URL: Outputs the deployed environment URL if the previous steps were successful.
name: Build and Deploy Streamlit Dynamic Application

on:
  push:
    branches:
      - '**'  # Trigger the workflow on any branch push
  workflow_dispatch:  # Allow manual trigger of the workflow

jobs:
  deployment:
    runs-on: ubuntu-latest  # Use the latest version of the Ubuntu runner
    environment: 
      name: ${{ github.ref_name }}  # The environment will be named based on the branch (e.g., "main", "feature-xyz")
      url: ${{ steps.set-url.outputs.deployed_url }}  # Dynamically set the environment URL after deployment

    steps:
      - name: Checkout code
        uses: actions/checkout@v2  # Check out the code from the repository for the current branch

      - name: Prepare Environment
        run: |
          sudo apt-get update  # Update the system's package index
          sudo apt-get install python3-pip  # Install Python and pip (for package management)
          sudo pip3 install awsebcli  # Install the AWS Elastic Beanstalk CLI
          # Install Poetry
          curl -sSL https://install.python-poetry.org | python3 -  # Install Poetry
          echo "$HOME/.local/bin" >> $GITHUB_PATH  # Add Poetry to PATH

      - name: Install dependencies with Poetry
        run: |
          poetry install --no-interaction --no-root  # Install dependencies without creating the project environment

      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pypoetry
            ~/.local/share/pypoetry/virtualenvs
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/pyproject.toml') }}  # Use a key based on the pyproject.toml hash
          restore-keys: |
            ${{ runner.os }}-poetry-


      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1  # Use AWS credentials stored in GitHub secrets
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}  # Access key for AWS
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}  # Secret access key for AWS
          aws-region: eu-west-2  # AWS region where resources are located (Elastic Beanstalk, ECR)

      - name: Login to Amazon ECR
        id: login-ecr  # Step ID to reference later if needed
        uses: aws-actions/amazon-ecr-login@v1  # Login to Amazon Elastic Container Registry (ECR)

      - name: Build and tag Docker image
        id: build-image  # Step ID to reference in future steps
        uses: docker/build-push-action@v2  # Build a Docker image
        with:
          context: .  # Use the current directory as the Docker build context
          push: false  # Do not push the image to DockerHub or ECR (for local testing/building)
          tags: streamlit-demo:latest  # Tag the Docker image as "latest" for easy reference

      - name: Deploy to Elastic Beanstalk environment
        id: create-or-update-environment
        run: |
          set -x
      
          branch_name=$(echo ${{ github.ref }} | sed 's/refs\/heads\///')  # Extract the branch name
      
          # Use grep to extract the Jira ticket ID (assumes it starts with WEAT-)
          jira_ticket_id=$(echo "$branch_name" | grep -oE 'WEAT-[0-9]+' | head -n 1)
      
          # Check if the branch is 'main' or if a Jira ticket ID was found
          if [ "$branch_name" == "main" ]; then
            app_name="WeatherApp"  # Use "WeatherApp" for the main branch
          elif [ -n "$jira_ticket_id" ]; then
            app_name="${jira_ticket_id}-WeatherApp"  # Use the Jira ID for other branches
          else
            echo "No valid application name found. Aborting deployment."
            exit 1
          fi
      
          env_name="${jira_ticket_id}"  # Create a shorter environment name using the Jira ticket ID
      
          # Initialize the application (will not create it if it already exists)
          if eb init "$app_name" --platform docker --region eu-west-2 --verbose; then
            echo "Application initialized successfully."
          else
            echo "Application does not exist, attempting to create it."
            if eb create "$app_name" --platform docker --region eu-west-2 --verbose; then
              echo "Application created successfully."
            else
              echo "Failed to create application: $app_name. Exiting."
              exit 1
            fi
          fi
      
          # List existing environments and capture the output
          existing_envs=$(eb list)
      
          # Check if there are existing environments
          if [ -z "$existing_envs" ]; then
            echo "No existing environments found. Creating a new environment."
            # Create a new environment if none exist
            aws elasticbeanstalk create-environment \
              --application-name "$app_name" \
              --environment-name "$env_name" \
              --platform-branch-name "Docker running on 64bit Amazon Linux 2023" \
              --option-settings file://options.json \
              --tier "WebServer" \
              --cname-prefix "$jira_ticket_id"  # Use Jira ID for CNAME prefix
          else
            # Check if the specific environment exists
            if echo "$existing_envs" | grep -q "${env_name}"; then
              echo "Environment '${env_name}' already exists. Deploying to existing environment."
              # Deploy to the existing environment
              aws elasticbeanstalk update-environment \
                --environment-name "$env_name" \
                --option-settings file://options.json
            else
              echo "Existing environments found, but '${env_name}' does not exist. Creating a new environment."
              # Create a new environment if the specific one does not exist
              aws elasticbeanstalk create-environment \
                --application-name "$app_name" \
                --environment-name "$env_name" \
                --platform-branch-name "Docker running on 64bit Amazon Linux 2023" \
                --option-settings file://options.json \
                --tier "WebServer" \
                --cname-prefix "$jira_ticket_id"  # Use Jira ID for CNAME prefix
            fi
          fi
        


      - name: Get Elastic Beanstalk Environment URL
        id: set-url  # Step ID to reference the URL later
        run: |
          # Use the previously defined environment name for URL retrieval
          deployed_url=$(eb status ${env_name} | grep CNAME | awk '{print $2}')  # Get the CNAME (URL) of the newly created environment
          if [ -n "$deployed_url" ]; then
            echo "deployed_url=$deployed_url" >> $GITHUB_ENV  # Set the URL as an environment variable for future steps
          else
            echo "Failed to retrieve the deployed URL. Exiting."
            exit 1
          fi

      - name: Set Environment URL
        if: success()  # Only run this step if the previous steps were successful
        run: |
          echo "Deployed URL: $deployed_url"  # Output the deployed environment URL
